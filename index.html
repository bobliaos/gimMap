<html>
	<head>
		<title>HELLO three.js</title>
		<style type="text/css">
			canvas{width: 100%;height: 100%}
		</style>
        <script type="text/javascript" src="js/three.min.js"></script>
        <script type="text/javascript" src="js/stats.min.js"></script>
        <script type="text/javascript" src="js/tween.min.js"></script>
	</head>
	<body style="padding: 0;margin: 0">
        <script type="text/javascript">
            var size = 400;
            var meshes = new Array();
            var stats;

            var scene;
            var camera;
            var renderer;

            function addScene()
            {
                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight, 0.1, 1000);
//                camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 10, 1000 );
                camera.position.z = 500;
                renderer = new THREE.WebGLRenderer({antialias:true});
                renderer.setClearColorHex(0x888888);
                renderer.setSize(window.innerWidth,window.innerHeight);
                document.body.appendChild(renderer.domElement);
            }

            function addLights()
            {
                var ambientLight = new THREE.AmbientLight(0x222222);            //LambertMaterial响应颜色
//                scene.add(ambientLight);

                var directionalLight = new THREE.DirectionalLight(0x00FF00,1);  //第二个参数范围[0,1]
                directionalLight.position.set(500,500,500);                     //只跟角度有关系
//                scene.add(directionalLight);

                var pointLight = new THREE.PointLight(0xFFFFFF,1);
                pointLight.position.set(0,0,500);
                scene.add(pointLight);
            }

            function addStats()
            {
                stats = new Stats();
                stats.setMode(2);
                stats.domElement.style.position = "absolute";
                stats.domElement.style.left = "0px";
                stats.domElement.style.top = "0px";
                document.body.appendChild(stats.domElement);
                //setInterval(function(){stats.begin();stats.end();},1000 / 60)
            }

            function addLine()
            {
                var lineX = Math.random() * size - size * 0.5;
                var lineY = Math.random() * size - size * 0.5;
                var lineZ = Math.random() * size - size * 0.5;
                var targetVector3 = new THREE.Vector3(lineX,lineY,lineZ);

                var geometry = new THREE.Geometry();
                geometry.vertices.push(new THREE.Vector3(0,0,0),targetVector3);
                var lineColor = Math.random() * 0xFFFFFF;
                geometry.colors.push(new THREE.Color(0xFFFFFF),new THREE.Color(lineColor));

                var material = new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});

                var line = new THREE.Line(geometry,material,THREE.LinePieces);
                scene.add(line);
                meshes.push(line);
            }

            function addBox(boxSize)
            {
                var geometry = new THREE.BoxGeometry(boxSize,boxSize,2);
//                var material = new THREE.MeshBasicMaterial({color:Math.random() * 0xFFFFFF});
                var material = new THREE.MeshLambertMaterial({color:0xFFFFFF * Math.random()});
                var cube = new THREE.Mesh(geometry,material);
                cube.position.x = Math.random() * 600 - 300;
                cube.position.y = Math.random() * 600 - 300;
                cube.position.z = Math.random() * 600 - 300;
//                function cubeAnimate()
//                {
//                    setTimeout(cubeAnimate,1000 / 60);
//                    cube.position.z += Math.random() * 600 - 300;
//                }
//                cubeAnimate();
                scene.add(cube);
                meshes.push(cube);

                new TWEEN.Tween(cube.position).to({z: - Math.random() * 500},Math.random() * 2000 + 500).easing( TWEEN.Easing.Elastic.InOut ).repeat(Infinity).start();
            }

            var texture;
            function addTexturePlane()
            {
                var geometry = new THREE.PlaneGeometry(500,500,1,1);
                geometry.vertices[0].z = -120;
//                geometry.vertices[0].uv = new THREE.Vector2(0,0);
//                geometry.vertices[1].uv = new THREE.Vector2(1,0);
//                geometry.vertices[2].uv = new THREE.Vector2(1,1);
//                geometry.vertices[3].uv = new THREE.Vector2(0,1);

                var textureURL = "http://127.0.0.1/test/texture.png";
//                var texture = THREE.ImageUtils.loadTexture(textureURL,null,function(t){});

                texture = new THREE.Texture(myCanvas);
                texture.needsUpdate = true;
                var material = new THREE.MeshBasicMaterial({map:texture});
//                var material = new THREE.MeshBasicMaterial({color:0x0099CC});
                var mesh = new THREE.Mesh(geometry,material);
                mesh.scale.x = 0.5;
                mesh.scale.y = 0.5;
                mesh.position.y = 300;
                scene.add(mesh);

                addTextureBox();
            }

            function addTextureBox()
            {
                var box = new THREE.CubeGeometry(100,100,100);
                var material = new THREE.MeshBasicMaterial({map:texture});
                var mesh = new THREE.Mesh(box,material);
                scene.add(mesh);
                meshes.push(mesh);
            }

            function render()
            {
                requestAnimationFrame(render);
                renderer.render(scene,camera);

                texture.needsUpdate = true;
                for(var key in meshes)
                {
                    meshes[key].rotation.y += Math.random() * 0.1;
                    meshes[key].rotation.x += Math.random() * 0.1;
                }

                stats.update();
                TWEEN.update();
            }

            function drawClock()
            {
                var now = new Date();
                var sec = now.getSeconds(),min = now.getMinutes(),hour = now.getHours();
                hour = hour >= 12 ? hour - 12 : hour;

                var context = document.getElementById("myCanvas").getContext("2d");

                context.save();
                context.clearRect(0,0,500,500);

                context.lineCap = "round";

                var centerX = 250;
                var centerY = 250;
                var innerRadius = 180;
                var outRadius = 220;

                context.lineWidth = 8;
                context.fillStyle = "#FF9900";
                context.beginPath();
                context.rect(0,0,500,500);
                context.fill();

                context.lineWidth = 8;
                context.strokeStyle = "#FFFFFF";
                context.fillStyle = "#222222";
                context.beginPath();
                context.arc(centerX,centerY,outRadius + 20,0,Math.PI * 2);
                context.stroke();
                context.fill();

                context.lineWidth = 11;
                context.strokeStyle = "#FFFFFF";
                context.beginPath();
                for(var i = 0;i < 12;i ++)
                {
                    var radian = i * (Math.PI / 6);
                    var startX = Math.cos(radian) * innerRadius + centerX;
                    var startY = Math.sin(radian) * innerRadius + centerY;
                    var endX = Math.cos(radian) * outRadius + centerX;
                    var endY = Math.sin(radian) * outRadius + centerY;
                    context.moveTo(startX,startY);
                    context.lineTo(endX,endY);
                }
                context.stroke();

                var hourRadius = 120;
                var hourRadian = hour / 12 * (Math.PI * 2) + (min / 60) * (Math.PI / 6) - Math.PI / 2;
                var hourEndX = Math.cos(hourRadian) * hourRadius + centerX;
                var hourEndY = Math.sin(hourRadian) * hourRadius + centerY;
                context.lineWidth = 12;
                context.lineCap = "square";
                context.strokeStyle = "#EEEEEE";
                context.beginPath();
                context.moveTo(centerX,centerY);
                context.lineTo(hourEndX,hourEndY);
                context.stroke();

                var minRadius = 150;
                var minRadian = min / 60 * (Math.PI * 2) - Math.PI / 2;
                var minEndX = Math.cos(minRadian) * minRadius + centerX;
                var minEndY = Math.sin(minRadian) * minRadius + centerY;
                context.lineWidth = 8;
                context.strokeStyle = "#FFFFFF";
                context.beginPath();
                context.moveTo(centerX,centerY);
                context.lineTo(minEndX,minEndY);
                context.stroke();

                var secRadius = 180;
                var secRadian = sec / 60 * (Math.PI * 2) - Math.PI / 2;
                var secEndX = Math.cos(secRadian) * secRadius + centerX;
                var secEndY = Math.sin(secRadian) * secRadius + centerY;
                context.lineWidth = 1;
                context.strokeStyle = "#FF0033";
                context.beginPath();
                context.moveTo(centerX,centerY);
                context.lineTo(secEndX,secEndY);
                context.stroke();
            }

            function init()
            {
                drawClock();
                setInterval(drawClock,100);

                addScene();
                addLights();

                addTexturePlane();
                for(var i=0;i < 10;i ++)
                {
                    addLine();
                    addBox(30);
                }

                addStats();
                render();
            }

            window.onload = init;
        </script>
	<canvas id="myCanvas" width="500" height="500" style="display: none;position: absolute;top: 120px;left: 20px;background: #105cb6;width: 500px;height: 500px;">不支持CANVAS</canvas>
    </body>
</html>
